dir="/var/cache/surveillance/cam"
minfree=$((100*1000000))
device=/dev/v4l/by-id/usb-Syntek_Semiconductor_USB_2.0_Video_Capture_Controller-video-index0
virtpref=/dev/v4l/by-id/Loopback_video_device_
interval=2
ncams=3
switchdur=0.320
#minscene=0.005
minscene=0.003

seglen=600

globalargs="-loglevel warning -y -vsync passthrough"

durarg=
#durarg="-t ${seglen:?}"

codecargs="-codec h264 -pix_fmt yuv422p -preset veryfast -crf 30"
#codecargs="-codec mpeg4"

muxerargs="-f segment -segment_time ${seglen:?} -strftime 1"
#muxerargs=""

fontfile="/usr/share/fonts/TTF/DejaVuSans.ttf"

exnotswitching="between(mod(t,${interval:?}),${switchdur:?},${interval:?})"
exncam="floor(1+mod(t/${interval:?},${ncams:?}))"
fpsfilter="fps=12.5"
exdynascene="gt(gt(scene,${minscene:?})+eq(mod(n,60),0),0)"
ptsmono="setpts='PTS-(RTCSTART/(TB*1000000))'"

stampbox="drawtext=fontfile=${fontfile:?}:boxcolor=0x000000AA:box=1:fontsize=24:fontcolor='white':text='%{localtime\:%F %T}'"
mkidbox() { echo "drawtext=fontfile=${fontfile:?}:boxcolor=0x000000AA:box=1:fontsize=24:y=line_h:fontcolor='white':text='${1:?}'"; }
#  t\:%{e\:t}

shopt -s nullglob

fm_monitor_backend() {
    cd "${dir:?}"
    exec inotifywait -m -r . -e create -e close_write
}

fm_monitor_frontend() {
    local d e f pid
    local -A pids
    cd "/var/cache/surveil/cam"
    while true; do
    while read d e f; do
        case $e in
        'CREATE')
            echo "retrieving file $d$f"
            mkdir -p "$d"
            </dev/null ssh -q -oServerAliveInterval=300 localhost 'tail --pid=${PPID:?} -c +1 -f "'"$dir/$d$f"'"' >>"$d$f" &
            pids["$d$f"]=$!
            ;;
        'CLOSE_WRITE,CLOSE')
            echo "END retrieving file $d$f"
            if [ -n "${pids["$d$f"]}" ]; then
                prevsz=0
                while true; do
                    sleep 30
                    sz=`stat -c %s "$d$f"`
                    if [ x"$sz" = x"$prevsz" ]; then
                        echo "file '$d$f' stopped growing; killing ssh"
                        kill "${pids["$d$f"]}"
                        break
                    fi
                    prevsz=$sz
                done &
                unset pids["$d$f"]
            fi
            ;;
        esac
    done < <(
        </dev/null ssh -oServerAliveInterval=300 localhost /home/il/surveil/fm monitor_backend
    )
    sleep 10
    done
}

fm_mycycle_start() {
    "$THISDIR/mycycle" --device="${device:?}" --interval="${interval:?}" --ncams="${ncams:?}" >/dev/null &
    fm_mycycle_pid=$!
}

fm_mycycle_stop() {
    if [ -n "${ffmpeg_pid}" ]; then
        kill -TERM ${fm_mycycle_pid:?} 2>/dev/null || true
        fm_mycycle_pid=
    fi
}

fm_killffmpeg() {
    if [ -n "${ffmpeg_pid}" ]; then
        kill -TERM "${ffmpeg_pid:?}" 2>/dev/null || true
        ffmpeg_pid=
    fi
}

fm_killwdog() {
    if [ -n "${ffmpeg_watchdog_pid}" ]; then
        kill -TERM "${ffmpeg_watchdog_pid:?}" 2>/dev/null || true
        ffmpeg_watchdog_pid=
    fi
}

fm_record_in_empty_dirs() {
    local station i subdir have
    ffmpeg_pid=
    fm_mycycle_pid=
    ffmpeg_watchdog_pid=

    station=${1:?}
    shift

    subdir="$station"
    mkdir -p "${subdir:?}/`date +%Y%m%d`" "${subdir:?}/`date --date=tomorrow +%Y%m%d`"

    if [ "x$1" = x"fm_rec_cam" ]; then
        fm_mycycle_start
    fi
    trap 'fm_mycycle_stop; fm_killffmpeg; fm_killwdog;' EXIT

    while true; do
        echo "writing to $subdir"
        mkdir -p $subdir

        pwd
        "$@"
        [ x"$rc" = x"0" ] || sleep 10
        #break
    done
}

fm_ffmpeg_watchdog() {
    local ffmpeg_pid=${1:?}
    local watchdir=${2:?}
    local newstate prevstate=

    cd "$watchdir"
    while true; do
        "$THISDIR/cleandisk" --dir . --minfree "$minfree"
        mkdir -p "`date --date=tomorrow +%Y%m%d`"
        newstate=`du -ksx .`
        #newstate="y"
        if [ x"$prevstate" = x"$newstate" ]; then
            echo
            echo "ffmpeg seems hung"
            echo
            fm_killffmpeg
            break
        fi
        prevstate=$newstate
        sleep 300
    done
}

fm_ffmpeg() {
    rc=1
    echo ffmpeg "$@"
    ffmpeg "$@" &
    ffmpeg_pid=$!
    fm_ffmpeg_watchdog "$ffmpeg_pid" "$subdir" &
    ffmpeg_watchdog_pid=$!

    echo
    echo "ffmpeg_pid: $ffmpeg_pid , ffmpeg_watchdog_pid: $ffmpeg_watchdog_pid , BASHPID: $BASHPID"
    echo

    rc=0
    wait $ffmpeg_pid || rc=$?
    fm_killwdog
}

fm_rec_cam() {
    local i filterstr= outmap=()

    local ncams2=${ncams:?}

#ncams2=1
#exnotswitching=1
#exdynascene=1
#exncam=1

    #filterstr="${filterstr}${filterstr:+;}[0:v]${fpsfilter:?},${ptsmono:?}[out-last]"

    filterstr="${filterstr}${filterstr:+;}[0:v]${fpsfilter:?},select=outputs=${ncams2:?}:expr='${exnotswitching:?}*${exncam:?}'"
    for ((i=0; i<ncams2; i++)); do
        filterstr="${filterstr}[mid$i]"
    done

    local day="%Y%m%d"
    local time="%H-%M-%S"


    #outmap+=( -map "[out-last]" -c huffyuv -f segment -segment_time 10 -segment_wrap 3 "/dev/shm/last%d.mkv" )

#virtpref
    for ((i=0; i<ncams2; i++)); do
        filterstr="${filterstr}${filterstr:+;}
        [mid$i]${ptsmono:?},`mkidbox $i`,split=3[virt$i][pic$i][file$i];[file$i]select='${exdynascene:?}',${stampbox:?}[out$i]
        "
        outmap+=(
            -map "[virt$i]" -f v4l2 "/dev/v4l/by-id/Loopback_video_device_$i"
            -map "[pic$i]" -updatefirst 1 "/dev/shm/cam$i.bmp"
            -map "[out$i]" $codecargs $muxerargs "${subdir:?}/${day:?}/cam$i-${time:?}.mkv" )
    done

    time fm_ffmpeg $globalargs \
        -f video4linux2 -ts abs -copyts -standard PAL $durarg -mysurvive -i "${device:?}" -filter_complex "$filterstr" "${outmap[@]}"
}

fm_all() {
    [ $# = 0 ] && set -- cam
    for st in "$@"; do
        fm_record_in_empty_dirs $st fm_rec_$st
    done
}

fm_resetup() {
    set -e
    set -o pipefail
    function errtrap {     es=$?;     echo "ERROR line $1: Command exited with status $es.">&2; }; trap 'errtrap $LINENO' ERR
    
    THISDIR=`cd "\`dirname \"${BASH_SOURCE[0]}\"\`" && pwd`
}
