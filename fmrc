device=/dev/video0
interval=4
ncams=3
switchdur=0.320

seglen=600

globalargs="-loglevel warning -y -vsync passthrough"

durarg=
#durarg="-t ${seglen:?}"

codecargs="-codec h264 -pix_fmt yuv422p -preset veryfast -crf 30"
#codecargs="-codec mpeg4"

muxerargs="-f segment -segment_time ${seglen:?} -strftime 1"
#muxerargs=""

fontfile="/usr/share/fonts/TTF/DejaVuSans.ttf"

exnotswitching="between(mod(t,${interval:?}),${switchdur:?},${interval:?})"
exncam="floor(1+mod(t/${interval:?},${ncams:?}))"
fpsfilter="fps=12.5"
exdynascene="gt(gt(scene,0.005)+eq(mod(n,60),0),0)"
ptsmono="setpts='PTS-(RTCSTART/(TB*1000000))'"

stampbox="drawtext=fontfile=${fontfile:?}: boxcolor=0x000000AA:box=1:fontsize=24:fontcolor='white':text='%{localtime\:%F %T}'"
#  t\:%{e\:t}

shopt -s nullglob

fm_mycycle_start() {
    $THISDIR/mycycle --device="${device:?}" --interval="${interval:?}" --ncams="${ncams:?}" >/dev/null &
    fm_mycycle_pid=$!
}

fm_mycycle_stop() {
    if [ -n "${ffmpeg_pid}" ]; then
        kill -TERM ${fm_mycycle_pid:?} 2>/dev/null || true
        fm_mycycle_pid=
    fi
}

fm_killffmpeg() {
    if [ -n "${ffmpeg_pid}" ]; then
        kill -TERM "${ffmpeg_pid:?}" 2>/dev/null || true
        ffmpeg_pid=
    fi
}

fm_killwdog() {
    if [ -n "${ffmpeg_watchdog_pid}" ]; then
        kill -TERM "${ffmpeg_watchdog_pid:?}" 2>/dev/null || true
        ffmpeg_watchdog_pid=
    fi
}

fm_record_in_empty_dirs() {
    local station i subdir have
    ffmpeg_pid=
    fm_mycycle_pid=
    ffmpeg_watchdog_pid=

    station=${1:?}
    shift

    subdir="$station"
    mkdir -p "${subdir:?}/`date +%Y%m%d`" "${subdir:?}/`date --date=tomorrow +%Y%m%d`"

    if [ "x$1" = x"fm_rec_cam" ]; then
        fm_mycycle_start
    fi
    trap 'fm_mycycle_stop; fm_killffmpeg; fm_killwdog;' EXIT

    while true; do
        echo "writing to $subdir"
        mkdir -p $subdir

        pwd
        "$@"
        [ x"$rc" = x"0" ] || sleep 10
        #break
    done
}

fm_ffmpeg_watchdog() {
    local ffmpeg_pid=${1:?}
    local watchdir=${2:?}
    local newstate prevstate=

    cd "$watchdir"
    while true; do
        mkdir -p "`date --date=tomorrow +%Y%m%d`"
        newstate=`du -ksx .`
        #newstate="y"
        if [ x"$prevstate" = x"$newstate" ]; then
            echo
            echo "ffmpeg seems hung"
            echo
            fm_killffmpeg
            break
        fi
        prevstate=$newstate
        sleep 120
    done
}

fm_ffmpeg() {
    rc=1
    echo ffmpeg "$@"
    ffmpeg "$@" &
    ffmpeg_pid=$!
    fm_ffmpeg_watchdog "$ffmpeg_pid" "$subdir" &
    ffmpeg_watchdog_pid=$!

    echo
    echo "ffmpeg_pid: $ffmpeg_pid , ffmpeg_watchdog_pid: $ffmpeg_watchdog_pid , BASHPID: $BASHPID"
    echo

    rc=0
    wait $ffmpeg_pid || rc=$?
    fm_killwdog
}

fm_rec_cam() {
    local i filterstr= outmap=()

    local ncams2=${ncams:?}

#ncams2=1
#exnotswitching=1
#exdynascene=1
#exncam=1

    filterstr="${filterstr}${filterstr:+;}[0:v]${fpsfilter:?},${ptsmono:?}[out-last]"
    filterstr="${filterstr}${filterstr:+;}[0:v]${fpsfilter:?},select=outputs=${ncams2:?}:expr='${exnotswitching:?}*${exncam:?}'"

    for ((i=0; i<ncams2; i++)); do
        filterstr="${filterstr}[mid$i]"
    done

    local day="%Y%m%d"
    local time="%H-%M-%S"

    #read day time<<<$(date +"$day $time")

    outmap+=( -map "[out-last]" -c huffyuv -f segment -segment_time 10 -segment_wrap 3 "/dev/shm/last%d.mkv" )
    #outmap+=( -map "[out-last]" -c huffyuv -f rawvideo /dev/null )

    for ((i=0; i<ncams2; i++)); do
        filterstr="${filterstr}${filterstr:+;}
        [mid$i]select='${exdynascene:?}',${stampbox:?},${ptsmono:?}[out$i]
        "
        outmap+=(
            -map "[out$i]" $codecargs $muxerargs "${subdir:?}/${day:?}/cam$i-${time:?}.mkv" )
    done

    time fm_ffmpeg $globalargs \
        -f video4linux2 -ts abs -copyts -standard PAL $durarg -mysurvive -i "${device:?}" -filter_complex "$filterstr" "${outmap[@]}"
}

fm_all() {
    [ $# = 0 ] && set -- cam
    for st in "$@"; do
        fm_record_in_empty_dirs $st fm_rec_$st
    done
}

fm_resetup() {
    set -e
    set -o pipefail
    function errtrap {     es=$?;     echo "ERROR line $1: Command exited with status $es.">&2; }; trap 'errtrap $LINENO' ERR
    
    THISDIR=`cd "\`dirname \"${BASH_SOURCE[0]}\"\`" && pwd`
}
