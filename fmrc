recdir="/var/cache/surveillance/cam"
repldst="/var/cache/surveil/cam"
minfree=$((100*1000000))
device=/dev/v4l/by-id/usb-Syntek_Semiconductor_USB_2.0_Video_Capture_Controller-video-index0
virtpref=/dev/v4l/by-id/Loopback_video_device_
interval=2
ncams=3
switchdur=0.320
#minscene=0.005
minscene=0.003

seglen=600

globalargs="-loglevel warning -y -vsync passthrough"

durarg=
#durarg="-t ${seglen:?}"

codecargs="-codec h264 -pix_fmt yuv422p -preset veryfast -crf 30"
#codecargs="-codec mpeg4"

muxerargs="-f segment -segment_time ${seglen:?} -strftime 1"
#muxerargs=""

denoise="hqdn3d=luma_spatial=24.0"

fontfile="/usr/share/fonts/TTF/DejaVuSans.ttf"

exnotswitching="between(mod(t,${interval:?}),${switchdur:?},${interval:?})"
exncam="floor(1+mod(t/${interval:?},${ncams:?}))"
fpsfilter="fps=12.5"
exdynascene="gt(gt(scene,${minscene:?})+eq(mod(n,60),0),0)"
ptsmono="setpts='PTS-(RTCSTART/(TB*1000000))'"

stampbox="drawtext=fontfile=${fontfile:?}:boxcolor=0x000000AA:box=1:fontsize=24:fontcolor='white':text='%{localtime\:%F %T}'"
mkidbox() { echo "drawtext=fontfile=${fontfile:?}:boxcolor=0x000000AA:box=1:fontsize=24:y=line_h:fontcolor='white':text='${1:?}'"; }
#  t\:%{e\:t}

shopt -s nullglob

repl_prompt='give me filename in the form: "file: $filename"'
repl_last_line='file contents follow...'
repl_openmsg='opening file: '

fm_repl_getclip_backend() {
    local s clip
    # save logger as &5
    # restore socket as &2
    exec 5>&1 1>&4 2>&4
    echo "$repl_prompt"
    read -r s
    s="${s%$'\r'}"
    case $s in
    'file: '*)
    ;;
    *)
    echo "bad command"
    exit 1
    ;;
    esac
    cd "$recdir"
    clip="${s#file: }"
    echo "$repl_openmsg$clip"
    exec 6<"$clip"
    echo "$repl_last_line"
    exec 2>&5
    tail --pid=$$ -c +1 -f "$clip" <&6 &
    exec 6<&- 1>&- 4>&-
    prevbytes=-1
    while read -r -t 240 bytes && [ x"$prevbytes" != x"$bytes" ]; do
        prevbytes=$bytes
    done
}

fm_monitor_backend() {
    cd "${recdir:?}"
    exec inotifywait -m -r . -e create
}

fm_monitor_frontend() {
    local d e f s pid
    cd "${repldst:?}"
    while true; do
    while read d e f; do
        case $e in
        'CREATE')
            if mkdir -p "$d"; then # could be disk full
            echo "retrieving file $d$f"
	    {
                echo "file: $d$f"
                while read -r s; do
                    s="${s%$'\r'}"
                    >&2 printf "%s\n" "$s"
                    case $s in
                    "$repl_last_line") break;;
                    "$repl_prompt"|"$repl_openmsg"*) : ;;
                    *) exit 1;;
                    esac
                done
		set -o noclobber
                exec pv -n -i200 >"$d$f" 2>&0
            } </dev/tcp/localhost/tailf 1>&0 &
	    fi
            ;;
        esac
    done < <(
        exec ssh -oServerAliveInterval=300 dvr /home/il/surveil/fm monitor_backend </dev/null
    )
    sleep 10
    done
}

fm_mycycle_start() {
    "$THISDIR/mycycle" --device="${device:?}" --interval="${interval:?}" --ncams="${ncams:?}" >/dev/null &
    fm_mycycle_pid=$!
}

fm_mycycle_stop() {
    if [ -n "${ffmpeg_pid}" ]; then
        kill -TERM ${fm_mycycle_pid:?} 2>/dev/null || true
        fm_mycycle_pid=
    fi
}

fm_killffmpeg() {
    if [ -n "${ffmpeg_pid}" ]; then
        kill -TERM "${ffmpeg_pid:?}" 2>/dev/null || true
        ffmpeg_pid=
    fi
}

fm_killwdog() {
    if [ -n "${ffmpeg_watchdog_pid}" ]; then
        kill -TERM "${ffmpeg_watchdog_pid:?}" 2>/dev/null || true
        ffmpeg_watchdog_pid=
    fi
}

fm_record() {
    local i subdir have
    ffmpeg_pid=
    fm_mycycle_pid=
    ffmpeg_watchdog_pid=

    cd "${recdir:?}"
    subdir="."

    if [ "x$1" = x"fm_rec_cam" ]; then
        fm_mycycle_start
    fi
    trap 'fm_mycycle_stop; fm_killffmpeg; fm_killwdog;' EXIT

    while true; do
        mkdir -p "${subdir:?}/`date --date=tomorrow +%Y%m%d`" "${subdir:?}/`date +%Y%m%d`"
        echo "writing to `cd "$subdir" && pwd`"

        "$@"
        [ x"$rc" = x"0" ] || sleep 10
        #break
    done
}

fm_ffmpeg_watchdog() {
    local ffmpeg_pid=${1:?}
    local watchdir=${2:?}
    local newstate prevstate=

    cd "$watchdir"
    while true; do
        "$THISDIR/cleandisk" --dir . --minfree "$minfree"
        mkdir -p "`date --date=tomorrow +%Y%m%d`"
        newstate=`du -ksx .`
        #newstate="y"
        if [ x"$prevstate" = x"$newstate" ]; then
            echo
            echo "ffmpeg seems hung"
            echo
            fm_killffmpeg
            break
        fi
        prevstate=$newstate
        sleep 300
    done
}

fm_ffmpeg() {
    rc=1
    echo ffmpeg "$@"
    ffmpeg "$@" &
    ffmpeg_pid=$!
    fm_ffmpeg_watchdog "$ffmpeg_pid" "$subdir" &
    ffmpeg_watchdog_pid=$!

    echo
    echo "ffmpeg_pid: $ffmpeg_pid , ffmpeg_watchdog_pid: $ffmpeg_watchdog_pid , BASHPID: $BASHPID"
    echo

    rc=0
    wait $ffmpeg_pid || rc=$?
    fm_killwdog
}

fm_rec_cam() {
    local i filterstr= outmap=()

    local ncams2=${ncams:?}

#ncams2=1
#exnotswitching=1
#exdynascene=1
#exncam=1

    #filterstr="${filterstr}${filterstr:+;}[0:v]${fpsfilter:?},${ptsmono:?}[out-last]"

    filterstr="${filterstr}${filterstr:+;}[0:v]${fpsfilter:?},select=outputs=${ncams2:?}:expr='${exnotswitching:?}*${exncam:?}'"
    for ((i=0; i<ncams2; i++)); do
        filterstr="${filterstr}[mid$i]"
    done

    local day="%Y%m%d"
    local time="%H-%M-%S"


    #outmap+=( -map "[out-last]" -c huffyuv -f segment -segment_time 10 -segment_wrap 3 "/dev/shm/last%d.mkv" )

#virtpref
    for ((i=0; i<ncams2; i++)); do
        denoisenow=
        [ $i -eq 2 ] && denoisenow="$denoise,"

        filterstr="${filterstr}${filterstr:+;}
        [mid$i]${ptsmono:?},`mkidbox $i`,split=3[virt$i][pic$i][file$i];[file$i]select='${exdynascene:?}',${denoisenow}${stampbox:?}[out$i]
        "
        outmap+=(
            -map "[virt$i]" -f v4l2 "/dev/v4l/by-id/Loopback_video_device_$i"
            -map "[pic$i]" -updatefirst 1 "/dev/shm/cam$i.bmp"
            -map "[out$i]" $codecargs $muxerargs "${subdir:?}/${day:?}/cam$i-${time:?}.mkv" )
    done

    time fm_ffmpeg $globalargs \
        -f video4linux2 -ts abs -copyts -standard PAL $durarg -mysurvive -i "${device:?}" -filter_complex "$filterstr" "${outmap[@]}"
}

fm_resetup() {
    set -e
    set -o pipefail
    function errtrap {     es=$?;     echo "ERROR line $1: Command exited with status $es.">&2; }; trap 'errtrap $LINENO' ERR
    
    THISDIR=`cd "\`dirname \"${BASH_SOURCE[0]}\"\`" && pwd`
}
